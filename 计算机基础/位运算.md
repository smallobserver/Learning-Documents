# 位运算

在做LeetCode的时候，位运算在很多情况下可以极大程度优化代码，特此记录一些常用的位运算操作。



### 移位运算（<< >>）

#### **1. 左移运算（`<<`）**

##### **定义**

- `x << n` 表示将 `x` 的二进制表示向左移动 `n` 位，在右侧补 `0`。
- 移位后，数值相当于 `x * (2^n)`。

##### **特点**

- **左移不会改变符号位**，符号位随内容移动。
- **高位溢出会丢弃**：超过表示范围的位被抛弃。

##### **示例**

```cpp
int x = 5; // 二进制：00000101
int result = x << 2; // 二进制：00010100
// 结果为 20
```

**过程：**

- 初始：`5 = 00000101`
- 左移 2 位：`00010100 = 20`

------



#### **2. 右移运算（`>>`）**

##### **定义**

- `x >> n` 表示将 `x` 的二进制表示向右移动 `n` 位。
- 移位后，数值相当于 `x / (2^n)`（向下取整）。

##### **两种右移方式**

1. 算术右移（带符号右移）：
   - 高位用符号位填充（保持正负号）。
   - 用于带符号整数。
2. 逻辑右移（无符号右移）：
   - 高位始终补 `0`。
   - 用于无符号整数。

##### **示例**

```cpp
int x = 20; // 二进制：00010100
int result = x >> 2; // 二进制：00000101
// 结果为 5
```

**过程：**

- 初始：`20 = 00010100`
- 右移 2 位：`00000101 = 5`

##### **带符号右移示例**

```cpp
int x = -20; // 二进制：11101100 （假设 8 位补码表示）
int result = x >> 2; // 二进制：11111011
// 结果为 -5
```

**过程：**

- 初始：`-20` 的补码为 `11101100`
- 右移 2 位后高位补符号位 `1`：`11111011 = -5`

------

#### **3. 左移和右移的数学意义**

##### **左移：乘法**

- 左移相当于乘以 `2^n`，但仅在不发生溢出的情况下成立。

- 示例：

  ```cpp
  int x = 3;
  cout << (x << 1); // 输出 6，相当于 3 * 2^1
  cout << (x << 3); // 输出 24，相当于 3 * 2^3
  ```

##### **右移：除法**

- 右移相当于整除 `2^n`，向下取整。

- 示例：

  ```cpp
  int x = 10;
  cout << (x >> 1); // 输出 5，相当于 10 / 2^1
  cout << (x >> 2); // 输出 2，相当于 10 / 2^2
  ```

------

#### **4. 注意事项**

1. **溢出问题**
   - 左移可能导致溢出，特别是当移位的位数接近或超过整数的位数时。
   - 例如，对于 `int` 类型（32 位），`1 << 32` 是未定义行为，因为移位超过了最大位数。
2. **符号位的处理**
   - 左移和右移都可能改变符号位。
   - 对带符号整数进行移位时，需注意符号位是否会被错误处理。
3. **效率**
   - 移位运算通常比乘法或除法更快，因此在需要快速计算 `2^n` 倍或 `1/(2^n)` 倍时，移位是一种高效的替代方法。

------

#### **5. 应用场景**

1. **快速乘除 2 的幂：**

   - 左移实现快速乘法，右移实现快速整除。
   - 例如：`x << 3` 等价于 `x * 8`，`x >> 2` 等价于 `x / 4`。

2. **掩码生成：**

   - 通过 `1 << n` 快速生成某个位的掩码。

   - 例如：

     ```c++
     int mask = 1 << 3; // 生成 00001000 的掩码
     ```

   - 例如：

     ```
     //快速生成 n长度的掩码
     ((1 << n)-1)
     ```

     

3. **状态压缩：**

   - 用位表示多个状态，移位可以高效操作状态值。

4. **低位提取：**

   - 使用右移结合按位与操作提取某些位的值。

   - 例如：

     ```c++
     int x = 0b10101100;
     int lowBits = (x >> 2) & 0b00001111; // 提取移位后的低 4 位
     ```

------

#### **6. 示例代码**

```c++
#include <iostream>
using namespace std;

int main() {
    int x = 5;

    // 左移
    cout << "x << 1: " << (x << 1) << endl; // 5 * 2 = 10

    // 右移
    cout << "x >> 1: " << (x >> 1) << endl; // 5 / 2 = 2

    // 掩码生成
    int mask = 1 << 3; // 第 3 位掩码
    cout << "Mask: " << mask << endl; // 输出 8 (二进制：00001000)

    return 0;
}
```

输出：

```bash
x << 1: 10
x >> 1: 2
Mask: 8
```

------

#### **总结**

- `<<` 左移：高效的乘法（乘以 2 的幂），右侧补零。
- `>>` 右移：高效的整除（除以 2 的幂），符号位的处理依赖于数据类型（带符号/无符号）。
- 移位运算在性能优化、状态压缩和位操作中有广泛的应用。



### **位取反**运算符(~)

#### **定义**

位取反运算符 `~` 是一种按位运算，作用是将操作数的每一位都取反：

- **1 变成 0**
- **0 变成 1**

取反运算的结果会受到操作数的位数和存储方式（如补码）的影响。对于整数类型，计算机使用的是**补码**表示。

------

#### **1. 工作原理**

假设操作数 `x` 是一个整数：

1. 将 `x` 转换为其二进制表示。
2. 对每一位执行取反操作（1 变 0，0 变 1）。
3. 取反后的结果仍是一个整数，以补码的形式表示。

------

#### **2. 补码和取反**

- 计算机中，整数是用 补码表示的：
  - **正数的补码**：与原码相同。
  - **负数的补码**：原码取反后加 1。
- 取反后会产生补码形式的负数。

公式：
对一个整数 `x`，其取反结果为：

```cpp
~x = -(x + 1)
```

------

#### **3. 示例**

##### **正数取反**

```cpp
int x = 5; // 二进制：00000101
int result = ~x; // 取反后：11111010
```

- 解释：
  1. `5` 的二进制：`00000101`。
  2. 取反：`11111010`。
  3. 结果是补码形式的负数：
     - 取反：`00000101`
     - 加 1：`00000110`，即 `-6`。
  4. 因此，`~5 = -6`。

##### **负数取反**

```cpp
int x = -5; // 二进制补码：11111011
int result = ~x; // 取反后：00000100
```

- 解释：
  1. `-5` 的补码表示：`11111011`。
  2. 取反：`00000100`，对应十进制为 `4`。
  3. 因此，`~-5 = 4`。

##### **零取反**

```cpp
int x = 0; // 二进制：00000000
int result = ~x; // 取反后：11111111
```

- `0` 的二进制：`00000000`。
- 取反：`11111111`，对应十进制为 `-1`。

------

#### **4. 应用场景**

##### **(1) 位掩码**

使用取反生成掩码：

```cpp
int mask = ~0b1111; // 生成掩码：高位为 1，低 4 位为 0
```

##### **(2) 布尔值反转**

在布尔值处理时，`~` 可以生成反转的布尔状态。

##### **(3) 位操作中的预处理**

在复杂的位操作中，取反常用于快速计算补集或屏蔽特定位。

------

#### **5. 注意事项**

##### **(1) 数据类型**

- 取反结果的位数取决于操作数的数据类型（如 `int`、`long`）。
- 操作数为无符号整数时，结果也为无符号。

##### **(2) 补码特性**

- ```
  ~
  ```

   运算受补码特性影响：

  - `~x` 的结果通常为负数。
  - 对于无符号数，`~x` 可能不会产生负数，而是一个大的正数。

------

#### **6. 示例代码**

##### **C++ 示例**

```
cpp复制代码#include <iostream>
using namespace std;

int main() {
    int x = 5;
    int y = -5;

    cout << "~x (5): " << ~x << endl; // 输出 -6
    cout << "~y (-5): " << ~y << endl; // 输出 4

    unsigned int z = 5;
    cout << "~z (unsigned 5): " << ~z << endl; // 结果依赖无符号处理

    return 0;
}
```

**输出**

```
arduino复制代码~x (5): -6
~y (-5): 4
~z (unsigned 5): 4294967290
```

------

#### **总结**

- `~` 运算符逐位取反，每一位上的 `1` 和 `0` 互换。
- **公式**：`~x = -(x + 1)`。
- 常用于位掩码、状态反转和快速补集计算。
- 结果取决于补码表示方式以及操作数的类型（有符号/无符号）。





### 表达式 `x & -x`

表达式 `x & -x` 在位运算中是一个常见技巧，用于提取 **`x` 的二进制表示中最低位的 1**。以下是详细的解析：

------

#### **1. 负数的补码表示**

在计算机中，负数是用补码表示的：

- **负数的补码**：先取反，再加 1。

- 如果 `x` 是一个正整数，那么 

  ```
  -x
  ```

   的二进制表示是：

  ```
  ~x + 1
  ```

------

#### **2. `x & -x` 的原理**

- 对于一个正整数 `x`：
  - 负数 `-x` 的二进制形式将保留 `x` 的最低位的 1，并将它上面的所有位取反。
  - 按位与操作 `x & -x` 会将 **除了最低位的 1 以外的所有位清零**，从而仅保留最低位的 1。

**具体步骤**

1. `x` 的二进制形式。
2. `-x = ~x + 1`，求得补码形式。
3. 按位与操作提取最低位的 1。

------

#### **3. 示例分析**

##### 示例 1：`x = 10`（十进制）

1. `x` 的二进制：

   ```
   00001010
   ```

2. `-x` 的二进制（补码）：

   - ```
     ~x
     ```

      取反：

     ```
     11110101
     ```

   - 加 1：

     ```
     11110110
     ```

3. 按位与：

   ```
   00001010   (x)
   &
   11110110   (-x)
   --------
   00000010   (结果)
   ```

结果为 `2`，即 `x` 的最低位 1 的值。

------

##### 示例 2：`x = 12`

1. `x` 的二进制：

   ```
   复制代码
   00001100
   ```

2. `-x` 的二进制（补码）：

   - ```
     ~x
     ```

      取反：

     ```
     复制代码
     11110011
     ```

   - 加 1：

     ```
     复制代码
     11110100
     ```

3. 按位与：

   ```
   markdown复制代码00001100   (x)
   &
   11110100   (-x)
   --------
   00000100   (结果)
   ```

结果为 `4`，即 `x` 的最低位 1 的值。

------

#### **4. 数学解释**

从数学角度看：

- `x & -x` 提取了 `x` 的二进制表示中最右侧的 `1`。
- 如果将 `x` 写成二进制形式，`x & -x` 的结果等于 `2^k`，其中 `k` 是最低位的 1 的位置（从 0 开始计数）。

------

#### **5. 应用场景**

1. **快速定位最低位的 1：**
   - 常用于状态压缩问题，如 N 皇后、子集枚举。
   - 在位图或状态表示中，可以快速找到某个位是否有效。
2. **逐位遍历：**
   - 在位运算中，`x & -x` 用来提取最低位的 1 后，可以用 `x &= (x - 1)` 删除最低位的 1，进入下一步操作。
3. **快速优化：**
   - 比如在某些算法中，仅操作最低位的 1，可以大幅减少复杂度。

------

#### **6. 示例代码**

**C++**

```
cpp复制代码#include <iostream>
using namespace std;

int main() {
    int x = 10; // 示例数
    int result = x & -x;
    cout << "Lowest bit of " << x << " is: " << result << endl;
    return 0;
}
```

输出：

```
arduino


复制代码
Lowest bit of 10 is: 2
```

------

#### **总结**

`x & -x` 是一个简单、高效的位运算技巧，主要用来提取最低位的 1。它利用了二进制补码的特性，使其在许多算法中非常常用，特别是在优化和状态处理相关的问题中。





### 表达式 `x & (x - 1)`

表达式 `x & (x - 1)` 是一个常见的位运算技巧，用于**清除二进制表示中最低位的 1**。以下是详细的解析和说明：

------

#### **1. 原理**

- 给定一个正整数 `x`，`x - 1` 会将 `x` 的二进制表示中最低位的 1 改为 0，同时将其右边的所有位变为 1。
- 按位与运算 `x & (x - 1)` 会保留 `x` 中与 `x - 1` 相同的高位，同时清除最低位的 1。

------

#### **2. 具体步骤**

1. `x` 的二进制形式：
   - 假设 `x` 是一个二进制数，最低位 1 位于第 `k` 位。
2. `x - 1` 的二进制形式：
   - `x - 1` 会将第 `k` 位的 1 变为 0，并将其右边所有位变为 1。
3. 按位与操作：
   - `x & (x - 1)` 会清除第 `k` 位的 1，并保留其他位不变。

------

#### **3. 示例分析**

##### 示例 1：`x = 10`（十进制）

1. `x` 的二进制：

   ```
   00001010
   ```

2. `x - 1` 的二进制：

   ```
   00001001
   ```

3. 按位与：

   ```
   00001010   (x)
   &
   00001001   (x - 1)
   --------
   00001000   (结果)
   ```

结果为 `8`，即清除了最低位的 1。

------

##### 示例 2：`x = 12`

1. `x` 的二进制：

   ```
   00001100
   ```

2. `x - 1` 的二进制：

   ```
   00001011
   ```

3. 按位与：

   ```
   00001100   (x)
   &
   00001011   (x - 1)
   --------
   00001000   (结果)
   ```

结果为 `8`，即清除了最低位的 1。

------

#### **4. 数学解释**

对于二进制数 `x`，`x & (x - 1)` 的效果是：

- **清除最低位的 1**。
- 如果 `x` 是 2 的幂（例如 `4 = 0100`），那么 `x & (x - 1)` 的结果是 `0`，因为只有一位是 1。

------

#### **5. 应用场景**

1. **计算二进制中 1 的个数：**

   - 利用 `x & (x - 1)`，可以快速清除最低位的 1，直到 `x` 变为 0。

   - 示例代码：

     ```
     cpp复制代码int countOnes(int x) {
         int count = 0;
         while (x > 0) {
             x &= (x - 1); // 清除最低位的 1
             count++;
         }
         return count;
     }
     ```

   - 时间复杂度为 **O(1 的位数)**，比逐位检查快得多。

2. **判断是否是 2 的幂：**

   - 一个数是 2 的幂，当且仅当它的二进制表示中有且只有一个 1。
   - 条件是 `x > 0 && (x & (x - 1)) == 0`。

3. **优化子集枚举：**

   - 在状态压缩（如动态规划）中，用 `x & (x - 1)` 来逐步生成子集，减少计算量。

------

#### **6. 示例代码**

**C++**

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 12; // 示例数
    int result = x & (x - 1);
    cout << "Result of x & (x - 1): " << result << endl;

    // 判断是否是 2 的幂
    int y = 16;
    if (y > 0 && (y & (y - 1)) == 0)
        cout << y << " is a power of 2." << endl;
    else
        cout << y << " is not a power of 2." << endl;

    return 0;
}
```

输出：

```bash
Result of x & (x - 1): 8
16 is a power of 2.
```

------

#### **总结**

`x & (x - 1)` 是一种高效的位运算技巧，主要作用是：

1. 清除二进制表示中最低位的 1。
2. 用于计算 1 的个数、判断 2 的幂等操作。

它在状态压缩、动态规划和低级位运算优化中非常有用，是位运算的一个重要工具。





