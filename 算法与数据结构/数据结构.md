# 数据结构



## 线性表

### 概要

线性表是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。本章先介绍线性表的几个基本组成部分：数组、单向链表、双向链表。

### 数组

数组有上界和下界，数组的元素在上下界内是连续的。

存储10,20,30,40,50的数组的示意图如下：

[![img](http://images.cnitblog.com/blog/497634/201402/231243264043298.jpg)](http://images.cnitblog.com/blog/497634/201402/231243264043298.jpg)

数组的特点是：数据是连续的；随机访问速度快。 数组中稍微复杂一点的是多维数组和动态数组。对于C语言而言，多维数组本质上也是通过一维数组实现的。至于动态数组，是指数组的容量能动态增长的数组；对于C语言而言，若要提供动态数组，需要手动实现；而对于C++而言，STL提供了Vector；对于Java而言，Collection集合中提供了ArrayList和Vector。

### 单向链表

单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。

单链表的示意图如下： [![img](http://images.cnitblog.com/blog/497634/201402/231244591436996.jpg)](http://images.cnitblog.com/blog/497634/201402/231244591436996.jpg)

表头为空，表头的后继节点是"节点10"(数据为10的节点)，"节点10"的后继节点是"节点20"(数据为10的节点)，...

**单链表删除节点**

[![img](http://images.cnitblog.com/blog/497634/201402/231246130639479.jpg)](http://images.cnitblog.com/blog/497634/201402/231246130639479.jpg)

删除"节点30"

**删除之前**："节点20" 的后继节点为"节点30"，而"节点30" 的后继节点为"节点40"。

**删除之后**："节点20" 的后继节点为"节点40"。

**单链表添加节点**

[![img](http://images.cnitblog.com/blog/497634/201402/231246431888916.jpg)](http://images.cnitblog.com/blog/497634/201402/231246431888916.jpg)

在"节点10"与"节点20"之间添加"节点15"

**添加之前**："节点10" 的后继节点为"节点20"。

**添加之后**："节点10" 的后继节点为"节点15"，而"节点15" 的后继节点为"节点20"。

单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。

### 双向链表

双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

双链表的示意图如下：

[![img](http://images.cnitblog.com/blog/497634/201402/231247423393589.jpg)](http://images.cnitblog.com/blog/497634/201402/231247423393589.jpg)

表头为空，表头的后继节点为"节点10"(数据为10的节点)；"节点10"的后继节点是"节点20"(数据为10的节点)，"节点20"的前继节点是"节点10"；"节点20"的后继节点是"节点30"，"节点30"的前继节点是"节点20"；...；末尾节点的后继节点是表头。

**双链表删除节点**

[![img](http://images.cnitblog.com/blog/497634/201402/231248185524615.jpg)](http://images.cnitblog.com/blog/497634/201402/231248185524615.jpg)

删除"节点30"

**删除之前**："节点20"的后继节点为"节点30"，"节点30" 的前继节点为"节点20"。"节点30"的后继节点为"节点40"，"节点40" 的前继节点为"节点30"。

**删除之后**："节点20"的后继节点为"节点40"，"节点40" 的前继节点为"节点20"。

**双链表添加节点**

[![img](http://images.cnitblog.com/i/497634/201403/241342164043381.jpg)](http://images.cnitblog.com/i/497634/201403/241342164043381.jpg)

在"节点10"与"节点20"之间添加"节点15"

**添加之前**："节点10"的后继节点为"节点20"，"节点20" 的前继节点为"节点10"。

**添加之后**："节点10"的后继节点为"节点15"，"节点15" 的前继节点为"节点10"。"节点15"的后继节点为"节点20"，"节点20" 的前继节点为"节点15"。

### 双链表的Java实现

```java
/**
 * Java 实现的双向链表。 
 * 注：java自带的集合包中有实现双向链表，路径是:java.util.LinkedList
 *
 * @author skywang
 * @date 2013/11/07
 */
public class DoubleLink<T> {

    // 表头
    private DNode<T> mHead;
    // 节点个数
    private int mCount;

    // 双向链表“节点”对应的结构体
    private class DNode<T> {
        public DNode prev;
        public DNode next;
        public T value;

        public DNode(T value, DNode prev, DNode next) {
            this.value = value;
            this.prev = prev;
            this.next = next;
        }
    }

    // 构造函数
    public DoubleLink() {
        // 创建“表头”。注意：表头没有存储数据！
        mHead = new DNode<T>(null, null, null);
        mHead.prev = mHead.next = mHead;
        // 初始化“节点个数”为0
        mCount = 0;
    }

    // 返回节点数目
    public int size() {
        return mCount;
    }

    // 返回链表是否为空
    public boolean isEmpty() {
        return mCount==0;
    }

    // 获取第index位置的节点
    private DNode<T> getNode(int index) {
        if (index<0 || index>=mCount)
            throw new IndexOutOfBoundsException();

        // 正向查找
        if (index <= mCount/2) {
            DNode<T> node = mHead.next;
            for (int i=0; i<index; i++)
                node = node.next;

            return node;
        }

        // 反向查找
        DNode<T> rnode = mHead.prev;
        int rindex = mCount - index -1;
        for (int j=0; j<rindex; j++)
            rnode = rnode.prev;

        return rnode;
    }

    // 获取第index位置的节点的值
    public T get(int index) {
        return getNode(index).value;
    }

    // 获取第1个节点的值
    public T getFirst() {
        return getNode(0).value;
    }

    // 获取最后一个节点的值
    public T getLast() {
        return getNode(mCount-1).value;
    }

    // 将节点插入到第index位置之前
    public void insert(int index, T t) {
        if (index==0) {
            DNode<T> node = new DNode<T>(t, mHead, mHead.next);
            mHead.next.prev = node;
            mHead.next = node;
            mCount++;
            return ;
        }

        DNode<T> inode = getNode(index);
        DNode<T> tnode = new DNode<T>(t, inode.prev, inode);
        inode.prev.next = tnode;
        inode.prev = tnode;
        mCount++;
        return ;
    }

    // 将节点插入第一个节点处。
    public void insertFirst(T t) {
        insert(0, t);
    }

    // 将节点追加到链表的末尾
    public void appendLast(T t) {
        DNode<T> node = new DNode<T>(t, mHead.prev, mHead);
        mHead.prev.next = node;
        mHead.prev = node;
        mCount++;
    }

    // 删除index位置的节点
    public void del(int index) {
        DNode<T> inode = getNode(index);
        inode.prev.next = inode.next;
        inode.next.prev = inode.prev;
        inode = null;
        mCount--;
    }

    // 删除第一个节点
    public void deleteFirst() {
        del(0);
    }

    // 删除最后一个节点
    public void deleteLast() {
        del(mCount-1);
    }
}
```







## 栈和队

### 一、栈

栈（stack），是一种线性存储结构，它有以下几个特点：

(01) 栈中数据是按照"后进先出（LIFO, Last In First Out）"方式进出栈的。

(02) 向栈中添加/删除数据时，只能从栈顶进行操作。

栈通常包括的三种操作：push、peek、pop。

push -- 向栈中添加元素。

peek -- 返回栈顶元素。

pop -- 返回并删除栈顶元素的操作。

#### 1.栈的示意图

[![img](http://images.cnitblog.com/blog/497634/201402/231830345432345.jpg)](http://images.cnitblog.com/blog/497634/201402/231830345432345.jpg)

栈中的数据依次是 30 --> 20 --> 10

#### 2.出栈

[![img](http://images.cnitblog.com/blog/497634/201402/231830540262932.jpg)](http://images.cnitblog.com/blog/497634/201402/231830540262932.jpg)

**出栈前**：栈顶元素是30。此时，栈中的元素依次是 30 --> 20 --> 10

**出栈后**：30出栈之后，栈顶元素变成20。此时，栈中的元素依次是 20 --> 10

#### 3. 入栈

[![img](http://images.cnitblog.com/blog/497634/201402/231831135784303.jpg)](http://images.cnitblog.com/blog/497634/201402/231831135784303.jpg)

**入栈前**：栈顶元素是20。此时，栈中的元素依次是 20 --> 10

**入栈后**：40入栈之后，栈顶元素变成40。此时，栈中的元素依次是 40 --> 20 --> 10

#### 4.栈的Java实现

JDK包中也提供了"栈"的实现，它就是集合框架中的Stack类。 本部分使用数组实现栈，能存储任意类型的数据。

```Java
/**
 * Java : 数组实现的栈，能存储任意类型的数据
 *
 * @author skywang
 * @date 2013/11/07
 */
import java.lang.reflect.Array;

public class GeneralArrayStack<T> {

    private static final int DEFAULT_SIZE = 12;
    private T[] mArray;
    private int count;

    public GeneralArrayStack(Class<T> type) {
        this(type, DEFAULT_SIZE);
    }

    public GeneralArrayStack(Class<T> type, int size) {
        // 不能直接使用mArray = new T[DEFAULT_SIZE];
        mArray = (T[]) Array.newInstance(type, size);
        count = 0;
    }

    // 将val添加到栈中
    public void push(T val) {
        mArray[count++] = val;
    }

    // 返回“栈顶元素值”
    public T peek() {
        return mArray[count-1];
    }

    // 返回“栈顶元素值”，并删除“栈顶元素”
    public T pop() {
        T ret = mArray[count-1];
        count--;
        return ret;
    }

    // 返回“栈”的大小
    public int size() {
        return count;
    }

    // 返回“栈”是否为空
    public boolean isEmpty() {
        return size()==0;
    }

    // 打印“栈”
    public void PrintArrayStack() {
        if (isEmpty()) {
            System.out.printf("stack is Empty\n");
        }

        System.out.printf("stack size()=%d\n", size());

        int i=size()-1;
        while (i>=0) {
            System.out.println(mArray[i]);
            i--;
        }
    }
}
```

### 二、队列

队列（Queue），是一种线性存储结构。它有以下几个特点： (1) 队列中数据是按照"先进先出（FIFO, First-In-First-Out）"方式进出队列的。 (2) 队列只允许在"队首"进行删除操作，而在"队尾"进行插入操作。 队列通常包括的两种操作：入队列 和 出队列。

#### 1.队列的示意图

[![img](http://images.cnitblog.com/blog/497634/201402/231907318284837.jpg)](http://images.cnitblog.com/blog/497634/201402/231907318284837.jpg)

队列中有10，20，30共3个数据。

#### 2.出队列

[![img](http://images.cnitblog.com/blog/497634/201402/231907485077436.jpg)](http://images.cnitblog.com/blog/497634/201402/231907485077436.jpg)

**出队列前**：队首是10，队尾是30。

**出队列后**：出队列(队首)之后。队首是20，队尾是30。

#### 3.入队列

[![img](http://images.cnitblog.com/blog/497634/201402/231908068809877.jpg)](http://images.cnitblog.com/blog/497634/201402/231908068809877.jpg)

**入队列前**：队首是20，队尾是30。

**入队列后**：40入队列(队尾)之后。队首是20，队尾是40。

#### 4.队列的Java实现

JDK中的Queue接口就是"队列"，它的实现类也都是队列，用的最多的是LinkedList。本部分使用数组实现队列，能存储任意类型的数据。

```java
/**
 * Java : 数组实现“队列”，只能存储int数据。
 *
 * @author skywang
 * @date 2013/11/07
 */
public class ArrayQueue {

    private int[] mArray;
    private int mCount;

    public ArrayQueue(int sz) {
        mArray = new int[sz];
        mCount = 0;
    }

    // 将val添加到队列的末尾
    public void add(int val) {
        mArray[mCount++] = val;
    }

    // 返回“队列开头元素”
    public int front() {
        return mArray[0];
    }

    // 返回“队首元素值”，并删除“队首元素”
    public int pop() {
        int ret = mArray[0];
        mCount--;
        for (int i=1; i<=mCount; i++)
            mArray[i-1] = mArray[i];
        return ret;
    }

    // 返回“栈”的大小
    public int size() {
        return mCount;
    }

    // 返回“栈”是否为空
    public boolean isEmpty() {
        return size()==0;
    }
}
```







## 树

### 一、树的介绍

#### 1.树的定义

树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。

[![img](http://images.cnitblog.com/i/497634/201403/270929194211610.jpg)](http://images.cnitblog.com/i/497634/201403/270929194211610.jpg)

把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

(01) 每个节点有零个或多个子节点；

(02) 没有父节点的节点称为根节点；

(03) 每一个非根节点有且只有一个父节点；

(04) 除了根节点外，每个子节点可以分为多个不相交的子树。

#### 2.树的基本术语

若一个结点有子树，那么该结点称为子树根的"双亲"，子树的根是该结点的"孩子"。有相同双亲的结点互为"兄弟"。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。

**结点的度**：结点拥有的子树的数目。

**叶子**：度为零的结点。

**分支结点**：度不为零的结点。

**树的度**：树中结点的最大的度。

**层次**：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。

**树的高度**：树中结点的最大层次。

**无序树**：如果树中结点的各子树之间的次序是不重要的，可以交换位置。

**有序树**：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。

**森林**：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。

### 二、二叉树的介绍

#### 1.二叉树的定义

二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。

[![img](http://images.cnitblog.com/i/497634/201403/270929530778327.jpg)](http://images.cnitblog.com/i/497634/201403/270929530778327.jpg)

#### 2. 二叉树的性质

二叉树有以下几个性质：

**性质1**：二叉树第i层上的结点数目最多为$2^{i-1}$ (i≥1)。

**性质2**：深度为k的二叉树至多有$2^k - 1$个结点(k≥1)。

**性质3**：包含n个结点的二叉树的高度至少为$log_2(n+1)$。

**性质4**：在任意一棵二叉树中，若叶子结点的个数为**n0**，度为2的结点数为**n2**，则**n0=n2+1**。

**2.1 性质1：二叉树第i层上的结点数目最多为**$2^{i-1}$(i≥1)

证明：下面用"数学归纳法"进行证明。

 (01) 当i=1时，第i层的节点数目为1。因为第1层上只有一个根结点，所以命题成立。

 (02) 假设当i>1，第i层的节点数目为$2^{i-1}$。这个是根据(01)推断出来的！

下面根据这个假设，推断出"第(i+1)层的节点数目为$2^{i}$"即可。

由于二叉树的每个结点至多有两个孩子，故"第(i+1)层上的结点数目" 最多是 "第i层的结点数目的2倍"。即，第(i+1)层上的结点数目最大值=2×$2^{i-1}$=$2^{i}$。

故假设成立，原命题得证！

**2.2 性质2：深度为k的二叉树至多有$2^{k}-1$个结点(k≥1)**

证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用"性质1"可知，深度为k的二叉树的结点数至多为：

 $ 2^0+2^1+…+2^{k-1}=2^k-1$

故原命题得证！

**2.3 性质3：包含n个结点的二叉树的高度至少为$log_2(n+1)$**

证明：根据"性质2"可知，高度为h的二叉树最多有$2^{h}-1$个结点。反之，对于包含n个节点的二叉树的高度至少为$log_2(n+1)$。

**2.4 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1**

证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)="0度结点数(n0)" + "1度结点数(n1)" + "2度结点数(n2)"。由此，得到等式一。

(等式一) n=n0+n1+n2

另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。

(等式二) n=n1+2n2+1

由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！

#### 3. 满二叉树，完全二叉树和二叉查找树

**3.1 满二叉树**

**定义**：高度为h，并且由$2^{h}-1$个结点的二叉树，被称为满二叉树。

[![img](http://images.cnitblog.com/i/497634/201403/270930282184259.jpg)](http://images.cnitblog.com/i/497634/201403/270930282184259.jpg)

**3.2 完全二叉树**

**定义**：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。

**特点**：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。

[![img](http://images.cnitblog.com/i/497634/201403/270931211084932.jpg)](http://images.cnitblog.com/i/497634/201403/270931211084932.jpg)

**3.3 二叉查找树**

**定义**：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] <= key[x]；如果y是x的右子树的一个结点，则key[y] >= key[x]。

[![img](http://images.cnitblog.com/i/497634/201403/270932052801072.jpg)](http://images.cnitblog.com/i/497634/201403/270932052801072.jpg)

在二叉查找树中：

(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

(03) 任意节点的左、右子树也分别为二叉查找树。

(04) 没有键值相等的节点（no duplicate nodes）。

对二叉查找树使用中序遍历，一定是从小到大排列。

在删除节点时，如果是节点，使用前驱或者后继可以快速恢复二叉搜索树  删除插入性能O(logn)

### 三、二叉查找树的Java实现

#### 1.二叉查找树节点的定义

```java
public class BSTree<T extends Comparable<T>> {

    private BSTNode<T> mRoot;    // 根结点

    public class BSTNode<T extends Comparable<T>> {
        T key;                // 关键字(键值)
        BSTNode<T> left;      // 左孩子
        BSTNode<T> right;     // 右孩子
        BSTNode<T> parent;    // 父结点

        public BSTNode(T key, BSTNode<T> parent, BSTNode<T> left, BSTNode<T> right) {
            this.key = key;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }
    }

        ......
}
```

BSTree是二叉树，它保含了二叉树的根节点mRoot；mRoot是BSTNode类型，而BSTNode是二叉查找树的节点，它是BSTree的内部类。BSTNode包含二叉查找树的几个基本信息：

(01) key -- 它是关键字，是用来对二叉查找树的节点进行排序的。

(02) left -- 它指向当前节点的左孩子。

(03) right -- 它指向当前节点的右孩子。

(04) parent -- 它指向当前节点的父结点。

#### 2.遍历

这里讲解前序遍历、中序遍历、后序遍历3种方式。

##### **2.1 前序遍历**

若二叉树非空，则执行以下操作：

(01) 访问根结点；

(02) 先序遍历左子树；

(03) 先序遍历右子树。

前序遍历代码

```java
private void preOrder(BSTNode<T> tree) {
    if(tree != null) {
        System.out.print(tree.key+" ");
        preOrder(tree.left);
        preOrder(tree.right);
    }
}

public void preOrder() {
    preOrder(mRoot);
}
```

##### **2.2 中序遍历**

若二叉树非空，则执行以下操作：

(01) 中序遍历左子树；

(02) 访问根结点；

(03) 中序遍历右子树。

中序遍历代码

```java
private void inOrder(BSTNode<T> tree) {
    if(tree != null) {
        inOrder(tree.left);
        System.out.print(tree.key+" ");
        inOrder(tree.right);
    }
}

public void inOrder() {
    inOrder(mRoot);
}
```

##### **2.3 后序遍历**

若二叉树非空，则执行以下操作：

(01) 后序遍历左子树；

(02) 后序遍历右子树；

(03) 访问根结点。

后序遍历代码

```java
private void postOrder(BSTNode<T> tree) {
    if(tree != null)
    {
        postOrder(tree.left);
        postOrder(tree.right);
        System.out.print(tree.key+" ");
    }
}

public void postOrder() {
    postOrder(mRoot);
}
```

看看下面这颗树的各种遍历方式：

[![img](http://images.cnitblog.com/i/497634/201403/270932554522177.jpg)](http://images.cnitblog.com/i/497634/201403/270932554522177.jpg)

对于上面的二叉树而言，

(01) 前序遍历结果： 3 1 2 5 4 6

(02) 中序遍历结果： 1 2 3 4 5 6

(03) 后序遍历结果： 2 1 4 6 5 3

#### 3. 查找

递归版本的代码

```java
/*
 * (递归实现)查找"二叉树x"中键值为key的节点
 */
private BSTNode<T> search(BSTNode<T> x, T key) {
    if (x==null)
        return x;

    int cmp = key.compareTo(x.key);
    if (cmp < 0)
        return search(x.left, key);
    else if (cmp > 0)
        return search(x.right, key);
    else
        return x;
}

public BSTNode<T> search(T key) {
    return search(mRoot, key);
}
```

非递归版本的代码

```java
/*
 * (非递归实现)查找"二叉树x"中键值为key的节点
 */
private BSTNode<T> iterativeSearch(BSTNode<T> x, T key) {
    while (x!=null) {
        int cmp = key.compareTo(x.key);

        if (cmp < 0) 
            x = x.left;
        else if (cmp > 0) 
            x = x.right;
        else
            return x;
    }

    return x;
}

public BSTNode<T> iterativeSearch(T key) {
    return iterativeSearch(mRoot, key);
}
```

#### 4. 最大值和最小值

查找最大值的代码

```java
/* 
 * 查找最大结点：返回tree为根结点的二叉树的最大结点。
 */
private BSTNode<T> maximum(BSTNode<T> tree) {
    if (tree == null)
        return null;

    while(tree.right != null)
        tree = tree.right;
    return tree;
}

public T maximum() {
    BSTNode<T> p = maximum(mRoot);
    if (p != null)
        return p.key;

    return null;
}
```

查找最小值的代码

```java
/* 
 * 查找最小结点：返回tree为根结点的二叉树的最小结点。
 */
private BSTNode<T> minimum(BSTNode<T> tree) {
    if (tree == null)
        return null;

    while(tree.left != null)
        tree = tree.left;
    return tree;
}

public T minimum() {
    BSTNode<T> p = minimum(mRoot);
    if (p != null)
        return p.key;

    return null;
}
```

#### 5. 前驱和后继

节点的前驱：是该节点的左子树中的最大节点。

节点的后继：是该节点的右子树中的最小节点。

查找前驱节点的代码

```java
/* 
 * 找结点(x)的前驱结点。即，查找"二叉树中数据值小于该结点"的"最大结点"。
 */
public BSTNode<T> predecessor(BSTNode<T> x) {
    // 如果x存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。
    if (x.left != null)
        return maximum(x.left);

    // 如果x没有左孩子。则x有以下两种可能：
    // (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。
    // (02) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父结点"就是"x的前驱结点"。
    BSTNode<T> y = x.parent;
    while ((y!=null) && (x==y.left)) {//满足条件，不断往上追溯，直到找到右祖先结点
        x = y;
        y = y.parent;
    }

    return y;
}
```

查找后继节点的代码

```java
/* 
 * 找结点(x)的后继结点。即，查找"二叉树中数据值大于该结点"的"最小结点"。
 */
public BSTNode<T> successor(BSTNode<T> x) {
    // 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。
    if (x.right != null)
        return minimum(x.right);

    // 如果x没有右孩子。则x有以下两种可能：
    // (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。
    // (02) x是"一个右孩子"，则查找"x的最低的父结点，并且该父结点要具有左孩子"，找到的这个"最低的父结点"就是"x的后继结点"。
    BSTNode<T> y = x.parent;
    while ((y!=null) && (x==y.right)) {//满足条件，不断往上追溯，直到找到右祖先结点
        x = y;
        y = y.parent;
    }

    return y;
}
```

#### 6. 插入

插入节点的代码

```java
/* 
 * 将结点插入到二叉树中
 *
 * 参数说明：
 *     tree 二叉树的
 *     z 插入的结点
 */
private void insert(BSTree<T> bst, BSTNode<T> z) {
    int cmp;
    BSTNode<T> y = null;
    BSTNode<T> x = bst.mRoot;

    // 查找z的插入位置
    while (x != null) {
        y = x;
        cmp = z.key.compareTo(x.key);
        if (cmp < 0)
            x = x.left;
        else
            x = x.right;
    }

    z.parent = y;
    if (y==null)
        bst.mRoot = z;
    else {
        cmp = z.key.compareTo(y.key);
        if (cmp < 0)
            y.left = z;
        else
            y.right = z;
    }
}

/* 
 * 新建结点(key)，并将其插入到二叉树中
 *
 * 参数说明：
 *     tree 二叉树的根结点
 *     key 插入结点的键值
 */
public void insert(T key) {
    BSTNode<T> z=new BSTNode<T>(key,null,null,null);

    // 如果新建结点失败，则返回。
    if (z != null)
        insert(this, z);
}
```

注：本文实现的二叉查找树是允许插入相同键值的节点的。

#### 7. 删除

删除节点的代码

```java
/* 
 * 删除结点(z)，并返回被删除的结点
 *
 * 参数说明：
 *     bst 二叉树
 *     z 删除的结点
 */
private BSTNode<T> remove(BSTree<T> bst, BSTNode<T> z) {
    BSTNode<T> x=null;
    BSTNode<T> y=null;

    if ((z.left == null) || (z.right == null) )
        y = z;
    else
        y = successor(z);

    if (y.left != null)
        x = y.left;
    else
        x = y.right;

    if (x != null)
        x.parent = y.parent;

    if (y.parent == null)
        bst.mRoot = x;
    else if (y == y.parent.left)
        y.parent.left = x;
    else
        y.parent.right = x;

    if (y != z) 
        z.key = y.key;

    return y;
}

/* 
 * 删除结点(z)，并返回被删除的结点
 *
 * 参数说明：
 *     tree 二叉树的根结点
 *     z 删除的结点
 */
public void remove(T key) {
    BSTNode<T> z, node; 

    if ((z = search(mRoot, key)) != null)
        if ( (node = remove(this, z)) != null)
            node = null;
}
```

#### 8. 打印

打印二叉查找树的代码

```java
/*
 * 打印"二叉查找树"
 *
 * key        -- 节点的键值 
 * direction  --  0，表示该节点是根节点;
 *               -1，表示该节点是它的父结点的左孩子;
 *                1，表示该节点是它的父结点的右孩子。
 */
private void print(BSTNode<T> tree, T key, int direction) {

    if(tree != null) {

        if(direction==0)    // tree是根节点
            System.out.printf("%2d is root\n", tree.key);
        else                // tree是分支节点
            System.out.printf("%2d is %2d's %6s child\n", tree.key, key, direction==1?"right" : "left");

        print(tree.left, tree.key, -1);
        print(tree.right,tree.key,  1);
    }
}

public void print() {
    if (mRoot != null)
        print(mRoot, mRoot.key, 0);
}
```

#### 9. 销毁

销毁二叉查找树的代码

```java
/*
 * 销毁二叉树
 */
private void destroy(BSTNode<T> tree) {
    if (tree==null)
        return ;

    if (tree.left != null)
        destroy(tree.left);
    if (tree.right != null)
        destroy(tree.right);

    tree=null;
}

public void clear() {
    destroy(mRoot);
    mRoot = null;
}
```

### 四、树的深度/广度优先遍历

树的深度优先遍历需要用到额外的数据结构--->栈；而广度优先遍历需要队列来辅助；这里以二叉树为例来实现。

```java
import java.util.ArrayDeque;

public class BinaryTree {
    static class TreeNode{
        int value;
        TreeNode left;
        TreeNode right;

        public TreeNode(int value){
            this.value=value;
        }
    }

    TreeNode root;

    public BinaryTree(int[] array){
        root=makeBinaryTreeByArray(array,1);
    }

    /**
     * 采用递归的方式创建一颗二叉树
     * 传入的是二叉树的数组表示法
     * 构造后是二叉树的二叉链表表示法
     */
    public static TreeNode makeBinaryTreeByArray(int[] array,int index){
        if(index<array.length){
            int value=array[index];
            if(value!=0){
                TreeNode t=new TreeNode(value);
                array[index]=0;
                t.left=makeBinaryTreeByArray(array,index*2);
                t.right=makeBinaryTreeByArray(array,index*2+1);
                return t;
            }
        }
        return null;
    }

    /**
     * 深度优先遍历，相当于先根遍历
     * 采用非递归实现
     * 需要辅助数据结构：栈
     */
    public void depthOrderTraversal(){
        if(root==null){
            System.out.println("empty tree");
            return;
        }       
        ArrayDeque<TreeNode> stack=new ArrayDeque<TreeNode>();
        stack.push(root);       
        while(stack.isEmpty()==false){
            TreeNode node=stack.pop();
            System.out.print(node.value+"    ");
            if(node.right!=null){
                stack.push(node.right);
            }
            if(node.left!=null){
                stack.push(node.left);
            }           
        }
        System.out.print("\n");
    }

    /**
     * 广度优先遍历
     * 采用非递归实现
     * 需要辅助数据结构：队列
     */
    public void levelOrderTraversal(){
        if(root==null){
            System.out.println("empty tree");
            return;
        }
        ArrayDeque<TreeNode> queue=new ArrayDeque<TreeNode>();
        queue.add(root);
        while(queue.isEmpty()==false){
            TreeNode node=queue.remove();
            System.out.print(node.value+"    ");
            if(node.left!=null){
                queue.add(node.left);
            }
            if(node.right!=null){
                queue.add(node.right);
            }
        }
        System.out.print("\n");
    }

    /** 
     *                  13
     *                 /  \
     *               65    5
     *              /  \    \
     *             97  25   37
     *            /    /\   /
     *           22   4 28 32
     */
    public static void main(String[] args) {
        int[] arr={0,13,65,5,97,25,0,37,22,0,4,28,0,0,32,0};
        BinaryTree tree=new BinaryTree(arr);
        tree.depthOrderTraversal();
        tree.levelOrderTraversal();
    }
}
```



### 五、其他树

#### 一、AVL树

AVL树是高度平衡的二叉查找树。它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。

[![img](http://images.cnitblog.com/i/497634/201403/281623404229547.jpg)](http://images.cnitblog.com/i/497634/201403/281623404229547.jpg)

上面的两张图片，左边的是AVL树，它的任何节点的两个子树的高度差别都<=1；而右边的不是AVL树，因为7的两颗子树的高度相差为2(以2为根节点的树的高度是3，而以8为根节点的树的高度是1)。

![VAL树-旋转操作](.\res\VAL树-旋转操作.png)

插入时，如果多个祖先节点失衡，只需要平衡最近的失衡节点

删除节点，需要调整后依次对失衡祖先进行检查调整



#### 二、红黑树

R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。

**红黑树的特性**:

**（1）每个节点或者是黑色，或者是红色。**

**（2）根节点是黑色。**

**（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**

**（4）如果一个节点是红色的，则它的子节点必须是黑色的。**

**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

**注意**：

(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。

(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

红黑树示意图如下：

[![img](http://images.cnitblog.com/i/497634/201403/251730074203156.jpg)](http://images.cnitblog.com/i/497634/201403/251730074203156.jpg)

##### **红黑树的应用**

红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。 例如，Java集合中的TreeMap和HashMap，都是通过红黑树去实现的。

#### 三、哈夫曼树

Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。

**定义**：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。

![哈夫曼树.jpg](.\res\哈夫曼树.jpg) 

(01) 路径和路径长度

> **定义**：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 **例子**：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。

(02) 结点的权及带权路径长度

> **定义**：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 **例子**：节点20的路径长度是3，它的带权路径长度= 路径长度x权 = 3 x 20 = 60。

(03) 树的带权路径长度

> **定义**：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。 **例子**：示例中，树的WPL= 1x100 + 2x50 + 3x20 + 3x10 = 100 + 100 + 60 + 30 = 290。

比较下面两棵树

![哈夫曼树比较示例.jpg](.\res\哈夫曼树比较示例.jpg) 

上面的两棵树都是以{10, 20, 50, 100}为叶子节点的树。

> 左边的树WPL=2x10 + 2x20 + 2x50 + 2x100 = 360
>
> 右边的树WPL=290

左边的树WPL > 右边的树的WPL。你也可以计算除上面两种示例之外的情况，但实际上右边的树就是{10,20,50,100}对应的哈夫曼树。至此，应该对哈夫曼树的概念有了一定的了解了，下面看看如何去构造一棵哈夫曼树。

#### **哈夫曼树的图文解析**

假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为：

> **1**. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；
>
> **2**. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
>
> **3**. 从森林中删除选取的两棵树，并将新树加入森林；
>
> **4**. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

以{5,6,7,8,15}为例，来构造一棵哈夫曼树。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/tree/huffman/03.jpg?raw=true&_=3706370)

**第1步**：创建森林，森林包括5棵树，这5棵树的权值分别是5,6,7,8,15。

**第2步**：在森林中，选择根节点权值最小的两棵树(5和6)来进行合并，将它们作为一颗新树的左右孩子(谁左谁右无关紧要，这里，我们选择较小的作为左孩子)，并且新树的权值是左右孩子的权值之和。即，新树的权值是11。 然后，将"树5"和"树6"从森林中删除，并将新的树(树11)添加到森林中。

**第3步**：在森林中，选择根节点权值最小的两棵树(7和8)来进行合并。得到的新树的权值是15。 然后，将"树7"和"树8"从森林中删除，并将新的树(树15)添加到森林中。

**第4步**：在森林中，选择根节点权值最小的两棵树(11和15)来进行合并。得到的新树的权值是26。 然后，将"树11"和"树15"从森林中删除，并将新的树(树26)添加到森林中。

**第5步**：在森林中，选择根节点权值最小的两棵树(15和26)来进行合并。得到的新树的权值是41。 然后，将"树15"和"树26"从森林中删除，并将新的树(树41)添加到森林中。

此时，森林中只有一棵树(树41)。这棵树就是我们需要的哈夫曼树！



##### 哈夫曼编码

![哈夫曼编码](.\res\哈夫曼编码.png)

通过哈夫曼树可以在不出现歧义的情况下编出来的码长度最短

通过出现次数来构造树，利用了权路径最短的原理。







## 并查集

### 一、并查集的介绍

并查集（Union/Find）从名字可以看出，主要涉及两种基本操作:合并和查找。这说明，初始时并查集中的元素是不相交的，经过一系列的基本操作(Union)，最终合并成一个大的集合。

而在某次合并之后，有一种合理的需求：某两个元素是否已经处在同一个集合中了？因此就需要Find操作。

并查集是一种 不相交集合 的数据结构，设有一个**动态集合**S={s1，s2，s3，.....sn}，每个集合通过一个代表来标识，该代表中集合中的某个元素。

比如，若某个元素 x 是否在集合 s1 中(Find操作)，返回集合 s1 的代表元素即可。这样，判断两个元素是否在同一个集合中也是很方便的，只要看find(x) 和 find(y) 是否返回同一个代表即可。

为什么是动态集合S呢？因为随着Union操作，动态集合S中的子集合个数越来越少。

数据结构的基本操作决定了它的应用范围，对并查集而言，一个简单的应用就是判断无向图的连通分量个数，或者判断无向图中任何两个顶点是否连通。

### 二、并查集的存储结构及实现分析

**①存储结构**

并查集(大S)由若干子集合si构成，并查集的逻辑结构就是一个森林。si表示森林中的一棵子树。一般以子树的根作为该子树的代表。

而对于并查集的存储结构，可用一维数组和链表来实现。这里主要介绍一维数组的实现。

根据前面介绍的基本操作再加上存储结构，并查集类的实现架构如下：

```java
public class DisjSets {
    private int[] s;
    private int count;//记录并查集中子集合的个数(子树的个数)

       public DisjSets(int numElements) {
       //构造函数，负责初始化并查集
       }

        public void unionByHeight(int root1, int root2){    
        //union操作
       }

       public int find(int x){
       //find 操作
      }
}
```

由于Find操作需要找到该子集合的代表元素，而代表元素是树根，因此需要保存树中结点的父亲，对于每一个结点，如果知道了父亲，沿着父结点链就可以最终找到树根。

为了简单起见，假设一维数组s中的每个元素 s[i] 表示该元素 i 的父亲。这里有两个需要注意的地方：①我们用一维数组来存储并查集，数组的元素s[i]表示的是结点的父亲的位置。②数组元素的下标 i 则是结点的标识。如：s[5]=4，节点5 在数组的第4号位置处。

假设有并查集中6个元素，初始时，所有的元素都相互独立，处在不同的集合中：

![img](http://images2015.cnblogs.com/blog/715283/201605/715283-20160512092946874-1968107559.jpg)

对应的一维数组初始化如下：

![img](http://images2015.cnblogs.com/blog/715283/201605/715283-20160512093206499-946248423.jpg)

因为，初始时每个元素代表一个集合，该元素本身就是树根。树根的父结点用 -1 来表示。代码实现如下：

```java
public DisjSets(int numElements) {
        s = new int[numElements];
        count = numElements;
        //初始化并查集,相当于新建了s.length 个互不相交的集合
        for(int i = 0; i < s.length; i++)
            s[i] = -1;//s[i]存储的是高度(秩)信息
    }
```

**②基本操作实现**

Union操作就是将两个不相交的子集合合并成一个大集合。简单的Union操作是非常容易实现的，因为只需要把一棵子树的根结点指向另一棵子树即可完成合并。

比如合并 节点3 和节点4：

![img](http://images2015.cnblogs.com/blog/715283/201609/715283-20160917221552352-697575435.png)

这里的合并很随意，把任意一棵子树的结点指向另一棵子树结点就完成了合并。

```java
public void union(int root1, int root2){
  s[root2] = root1;//将root1作为root2的新树根
}
```

但是，这只是一个简单的情况，如果待合并的两棵子树很大，而且高度不一样时，如何使得合并操作生成的新的子树的高度最小？因为高度越小的子树Find操作越快。

后面会介绍一种更好的合并策略，以支持Quick Union/Find。

Find操作就是查找某个元素所在的集合，返回该集合的代表元素。在union(3,4) 和 union(1,2)后，并查集如下：

![img](http://images2015.cnblogs.com/blog/715283/201609/715283-20160917221621664-276304966.png)

此时的一维数组如下：

![img](http://images2015.cnblogs.com/blog/715283/201609/715283-20160917221645695-1653305001.png)

此时一共有4个子集合。第一个集合的代表元素为0，第二个集合的代表元素为1，第三个集合的代表元素为3，第四个集合的代表元素为5，故：

find(2)返回1，find(0)返回0。因为 结点3 和 结点4 在同一个集合内，find(4)返回3，find(3)返回3。

```java
 public int find(int x){
  if(s[x] < 0)
    return x;
  else
    return find(s[x]);
 }
```

这里find(int x)返回的是最里层递归执行后，得到的值。由于只有树根的父结点位置小于0，故返回的是树根结点的标识。

（数组中索引 i 处的元素 s[i] 小于0，表示 结点i 是根结点.....）

### 三、Union/Find的改进----Quick Union/Find

上面介绍的Union操作很随意：任选一棵子树，将另一棵子树的根指向它即完成了合并。如果一直按照上述方式合并，很可能产生一棵非常不平衡的子树。

比如在上面的基础上union(2,3)后

![img](http://images2015.cnblogs.com/blog/715283/201609/715283-20160917221709180-221103150.png)

树越来越高了，此时会影响到Find操作的效率。比如，find(4)时，会一直沿着父结点遍历直到根，4-->3-->2-->1

这里引入一种新的合并策略，这是一种启发式策略，称之为**按秩合并：将秩小的子树的根指向秩大的子树的根。**

秩的定义：对每个结点，用秩表示结点高度的一个上界。为什么是上界？

因为路径压缩不完全与按高度求并兼容。路径压缩会改变树的高度，这样在Union操作之前，我们就无法获得子树的高度的精确值，因此就不计算高度的精确值，而是存储每棵树的高度的估计值，这个值称之为秩。

说了这么多，按秩求并就是在合并之前，先判断下哪棵子树更高，让矮的子树的根指向高的子树的根。

除了按高度求并之外，还可以按大小求并，即先判断下哪棵子树含有的结点数目多，让较小的子树的根指向较大的子树的根。

对于按高度求并，需要解释下数组中存储的元素：是高度的负值再减去1。这样，初始时，所有元素都是-1，而树根节点的高度为0，s[i]=-1。

按高度求并的代码如下：

```java
/**
     * 
     * @param root1 并查集中以root1为代表的某个子集
     * @param roo2 并查集中以root2为代表的某个子集
     * 按高度(秩)合并以root1 和 root2为代表的两个集合
     */
    public void unionByHeight(int root1, int root2){
        if(find(root1) == find(root2))
            return;//root1 与 root2已经连通了

        if(s[root2] < s[root1])//root2 is deeper
            s[root1] = root2;
        else{
            if(s[root1] == s[root2])//root1 and root2 is the same deeper
                s[root1]--;//将root1的高度加1
            s[root2] = root1;//将root2的根(指向)更新为root1
        }

        count--;//每union一次,子树数目减1
    }
```

#### 使用了路径压缩的Find的操作

上面程序代码find方法只是简单地把待查找的元素所在的根返回。路径压缩是指，在find操作进行时，**使find查找路径中的顶点(的父亲)都直接指向为树根（这很明显地改变了子树的高度）**

如何使find查找路径中经过的每个顶点都直接指向树根呢？只需要小小改动一下就可以了，这里用到了非常神奇的递归。修改后的find代码如下：

```java
public int find(int x){
        if(s[x] < 0)//s[x]为负数时,说明 x 为该子集合的代表(也即树根), 且s[x]的值表示树的高度
            return x;
        else 
            return s[x] = find(s[x]);//使用了路径压缩,让查找路径上的所有顶点都指向了树根(代表节点)
            //return find(s[x]); 没有使用 路径压缩
    }
```

因为递归最终得到的返回值是根元素。第5行将根元素直接赋值给s[x]，s[x]在每次递归过程中相当于结点x的父结点指针。

#### 关于路径压缩对按”秩“求并的兼容性问题

上面的unionByHeight(int , int)是按照两棵树的高度来进行合并的。但是find操作中的路径压缩会对树的高度产生影响。使用了路径压缩后，树的高度变化了，但是数组并没有更新这个变化。因为无法更新！！（我们没有在Find操作中去计算原来的树的高度，然后再计算新的树的高度，这样不现实，复杂度太大了）

举个例子：

依次高度unionByHeight(3, 4)、unionByHeight(1, 3)、unionByHeight(1, 0)后，并查集如下：

![img](http://images2015.cnblogs.com/blog/715283/201609/715283-20160917221738289-52951535.png)

此时，数组中的元素如下：

![img](http://images2015.cnblogs.com/blog/715283/201609/715283-20160917221800680-1425522009.png)

可以看出，此时只有两棵子树，一棵根结点为1，另一棵只有一个结点5。结点1的s[1]=-3，它所表示是该子树的高度为2，如果此时执行find(4)，会改变这棵树的高度！但是，数组s中存储的根的高度却没有更新，只会更新查找路径上的顶点的高度。执行完find(4)后，变成：

![img](http://images2015.cnblogs.com/blog/715283/201609/715283-20160917221820586-1276085996.png)

**查找路径为 4-->3-->1，find(4)使得查找路径上的所有顶点的父结点指向了根。如，将结点4 指向了根。但是没有根结点的高度（没有影响树根的秩），因为s[1]的值仍为-3**

**-3表示的高度为2，但是树的高度实际上已经变成了1**

执行find(4)之后，树实际上是这样的：

![img](http://images2015.cnblogs.com/blog/715283/201609/715283-20160917221844055-1168870298.png)

*（关于路径压缩对按秩合并有影响，我一直有个疑问，希望有大神指点啊）。。。。*

*路径压缩改变了子树的高度，而这个高度是按秩求的依据。，而且当高度改变之后，我们是无法更新这个变化了的高度的。那这会不会影响按秩求并的正确性？或者说使按秩求并达不到减小新生成的子树的高度的效果？*

### 四、并查集的应用

并查集数据结构非常简单，基本操作也很简单。但是用途感觉很大。比如，求解无向图中连通分量的个数，生成迷宫……

这些应用本质上就是：初始时都是一个个不连通的对象，经过一步步处理，变成连通的了。。。。。

如迷宫，初始时，起点和终点不连通，随机地打开起点到终点路径上的一个方向，直至起点和终点连通了，就生成了一个迷宫。

如，无向图的连通分量个数，初始时，将无向图中各个顶点视为不连通的子集合，对图中每一条边，相当于union这条边对应的两个顶点分别所在的集合，直至所有的边都处理完后，还剩下的集合的个数即为连通分量的个数。

### 五、完整代码

```java
public class DisjSets {
    private int[] s;
    private int count;//记录并查集中子集合的个数(子树的个数)


    public DisjSets(int numElements) {
        s = new int[numElements];
        count = numElements;
        //初始化并查集,相当于新建了s.length 个互不相交的集合
        for(int i = 0; i < s.length; i++)
            s[i] = -1;//s[i]存储的是高度(秩)信息
    }

    /**
     * 
     * @param root1 并查集中以root1为代表的某个子集
     * @param roo2 并查集中以root2为代表的某个子集
     * 按高度(秩)合并以root1 和 root2为代表的两个集合
     */
    public void unionByHeight(int root1, int root2){
        if(find(root1) == find(root2))
            return;//root1 与 root2已经连通了

        if(s[root2] < s[root1])//root2 is deeper
            s[root1] = root2;
        else{
            if(s[root1] == s[root2])//root1 and root2 is the same deeper
                s[root1]--;//将root1的高度加1
            s[root2] = root1;//将root2的根(指向)更新为root1
        }

        count--;//每union一次,子树数目减1
    }

    public void union(int root1, int root2){
        s[root2] = root1;//将root1作为root2的新树根
    }


    public void unionBySize(int root1, int root2){

        if(find(root1) == find(root2))
            return;//root1 与 root2已经连通了

        if(s[root2] < s[root1])//root2 is deeper
            s[root1] = root2;
        else{
            if(s[root1] == s[root2])//root1 and root2 is the same deeper
                s[root1]--;//将root1的高度加1
            s[root2] = root1;//将root2的根(指向)更新为root1
        }

        count--;//每union一次,子树数目减1
    }


    public int find(int x){
        if(s[x] < 0)//s[x]为负数时,说明 x 为该子集合的代表(也即树根), 且s[x]的值表示树的高度
            return x;
        else 
            return s[x] = find(s[x]);//使用了路径压缩,让查找路径上的所有顶点都指向了树根(代表节点)
            //return find(s[x]); 没有使用 路径压缩
    }

    public int find0(int x){
        if(s[x] < 0)
            return x;
        else 
            return find0(s[x]);
    }


    public int size(){
        return count;
    }
}
```





## B-树，B+树，B*树

### 一、概念

1. Binary Tree（二叉树）：二叉树的每个节点最多有两个子节点
2. Binary Search Tree（二叉搜索树）：二叉搜索树每个节点只存储一个键值，并且左子树（如果有）所有节点的值都要小于根节点的值，右子树（如果有）所有节点的值都要大于根节点的值。
3. B-Tree（Balanced Tree）：也就是今天要说的B-树，这里的-不是minus的意思，而是作为连接符的横杠，而我们也经常把B-树直接翻译为B树，所以B树与B-树通常是指一个概念，B代表的是Balance，而不是Binary。而B+树和B*树则是B-树的基础上正对不同场景的优化版本，将会在后文中有所介绍。

在大规模数据存储中，二叉查找树的深度会过大，当内存无法存储所有节点数据时，需要读取磁盘，进行IO操作，从而树的高度越高，I/O操作次数越多，效率也就越低。所以诸如之前所讲的红黑树，AVL树 因为树的高度太高而不适合这种需要大量IO操作的查询。所以，B树通过多叉的实现来降低树的高度，从而减少IO操作的次数。

### 二、B树（B-树）

为方便描述，下面一律用B树这个名称。B树是一种多路平衡搜索树（非二叉），若其是M路，则：

1. 任意非叶子节点最多可以有M个子女，且M>2；
2. 根节点的子女数为[2,M]；
3. 除了根节点以外的非叶子节点的子女数目为M/2（取上整）个到M个；
4. 每个节点存放至少M/2-1（取上整）和至多M-1个键值（至少两个）；
5. 非叶子节点的关键字个数=指向子女的指针个数-1；
6. 非叶子节点的关键字K[1],K[2],…,K[M-1]且有K[i]<K[i+1]；
7. 非叶子节点的指针P[1],P[2],…,P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树；
8. 所有叶子节点都位于同一层。

B树与二叉搜索树的最大区别在于其每个节点可以存不止一个键值，并且其子女不止两个，不过还是需要满足键值数=子女数-1。因此，对于相同数量的键值，B树比二叉搜索树要更加矮一些，特别是当M较大时，树高会更低。

[![B-Tree](http://oe0nilvpj.bkt.clouddn.com/B-Tree.png)](http://oe0nilvpj.bkt.clouddn.com/B-Tree.png) 上图中是一个简单的B树，在实际应用中，M可以取到很大，比如大于1000。一般情况下M的取值会使得每个磁盘盘块可以正好存放一个B数节点。上图中的35节点，35是一个key（或者说是索引，比如磁盘文件的文件名），而小黑块则代表的是该key所指向的内容在磁盘中实际的存储位置，是一个指针（比如35这个文件在硬盘中的位置）。

#### B树的搜索

B树的搜索与二叉搜索树类似，只不过需要在节点内部进行一次搜索查找。从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

#### B树的插入

B树的插入首先查找插入所在的节点，若该节点未满，插入即可，若该节点以及满了，则需要将该节点分裂，并将该节点的中间的元素移动到父节点上，若父节点未满，则结束，若父节点也满了，则需要继续分裂父节点，如此不断向上，直到根节点，如果根节点也满了，则分裂根节点，从而树的高度+1。

下面是B树插入的一个演示动画，往B树中一次插入的元素为6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4。 [![B-Tree Build](http://oe0nilvpj.bkt.clouddn.com/B-Tree.gif)](http://oe0nilvpj.bkt.clouddn.com/B-Tree.gif)

#### B树的删除

 ![B树删除节点](.\res\B树删除节点.png)

B树的删除首先要找到删除的节点，并删除节点中的元素，如果删除的元素有左右孩子，则上移左孩子最右节点或右孩子最左节点到父节点，若没有左右孩子，则直接删除。删除后，若某节点中元素数目不符合B树要求（小于M/2-1取上整），则需要看起相邻的兄弟节点是否有多余的元素，若有，则可以向父节点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有点类似于左旋）。若其相邻兄弟节点没有多余的元素，则与其兄弟节点合并成一个节点，此时也需要将父节点中的一个元素一起合并。

### 三、B+树

[![B+Tree](http://oe0nilvpj.bkt.clouddn.com/B+Tree.png)](http://oe0nilvpj.bkt.clouddn.com/B+Tree.png) B+树是B树的一个变种，其也是一种多路平衡搜索树，其与B树的主要区别是：

1. 非叶子节点的指针数量与关键字数量相等；
2. 非叶子节点的子树指针P[i]，指向关键字值属于[K[i],K[i+1]）的子树（B树是开区间，B+树是左闭右开，也就是说B树不允许关键字重复，而B+树允许）；
3. 所有关键字都在叶子节点出现，所有的叶子节点增加了一个链指针（稠密索引，且链表中的关键字切好是有序的）；
4. 非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储数据的数据层。

B+树主要是应文件系统所需而产生的。文件系统中，文件的目录是一级一级索引，只有最底层的叶子节点（文件）保存数据。非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，所有的非叶子节点都可以看成是索引部分。

非叶子节点（比如[5，28，65]）只是一个key（索引，实际的数据在叶子节点上，对应于叶子节点[5,8,9]中的5，[28,30,33]中的28，[65,73,79]中的65才是真正的数据或指向真实数据的指针）



#### B+树的搜索

B+的搜索与B树也是基本相同的。唯一的区别是B+树只有达到叶子结点才命中，因为只有叶节点中存放着真实数据或真实数据的指正，而B树可以在非叶子结点命中，其性能也等价于在元素全集做一次二分查找。

#### B+树的插入

B+树的插入与B树类似，如果节点中有多余的空间放入元素，则直接插入即可。如果节点本来就已经满了，则将其分裂为两个节点，并将其中间元素的索引放入到父节点中，在这里如果是叶子节点的话，是拷贝中间元素的索引到父节点中（因为叶子节点需要包含所有的元素），而如果是非叶子节点，则是上移节点的中间元素到父节点中。

下面是B+树插入的一个演示动画： [![B+Tree Insert](http://oe0nilvpj.bkt.clouddn.com/B+Tree.gif)](http://oe0nilvpj.bkt.clouddn.com/B+Tree.gif)

#### B+树的删除

在叶节点中删除元素，如果节点还满足B+树的要求，则okay。如果元素个数过少，并且其邻近兄弟节点有多余的元素，则从邻近兄弟节点中借一个元素，并修改父节点中的索引使其满足新的划分。如果其邻近兄弟节点也没有多余的元素，则将其和邻近兄弟节点合并，并且我们需要修改其父节点的索引以满足新的划分。并且如果父节点的索引元素太少不满足要求，则需要继续看起兄弟节点是否多余，如果没有多余则还需要与兄弟节点合并，如此不断向上，直到根节点。如果根节点中元素也被删除，则把根节点删除，并由合并来的节点作为新的根节点，树的高度减1。

### 四、B+树与B树的比较

B+树的非叶子节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，盘块所能容纳的关键字数量也越多，具有更好的空间局部性，一次性读入内存的需要查找的关键字也越多，相对的IO读写次数也就降低了。

另外对于B+树来说，因为非叶子节点只是叶子节点中关键字的索引，所以任何关键字的查找都必须走一条从根节点到叶子节点的路，所有关键字查询的路径长度相同。而若经常访问的元素离根节点很近，则B树访问更迅速，因为其不一定要到叶子节点。

数据库索引采用B+树的主要原因是B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，而也正是为了解决该问题，B+树应运而生。因为叶子节点中增加了一个链指针，B+树只需要取遍历叶子节点可以实现整棵树的遍历。而且数据库中基于范围的查询是非常频繁的，B树对基于范围的查询效率太低。

### 五、B*树

B*树又是B+树的变种，其与B+树的区别有：

1. B*树在B+树的非根和非叶子节点再增加指向兄弟节点的指针
2. B*树规定非叶子节点的键值个数至少为(2/3)*M，这样每个节点的使用率就从B+树的1/2上升到2/3，所以空间使用率更高。

B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；B*树分配新结点的概率比B+树要低，空间使用率更高；







## 图

### 一、图的基本概念

#### 1. 图的定义

定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为"顶点(vertex)"，而点与点之间的连线则被成为"边或弧"(edege)。通常记为，G=(V,E)。

#### 2. 图的种类

根据边是否有方向，将图可以划分为：**无向图**和**有向图**。

##### **2.1 无向图**

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/01.jpg?raw=true&_=3691463)

上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，

**(01)** V1={A,B,C,D,E,F}。 V1表示由"A,B,C,D,E,F"几个顶点组成的集合。

**(02)** E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)...等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。

##### **2.2 有向图**

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/02.jpg?raw=true&_=3691463)

上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中，

**(01)** V2={A,C,B,F,D,E,G}。 V2表示由"A,B,C,D,E,F,G"几个顶点组成的集合。

**(02)** A2={,,,,,,,,}。 E1是由矢量,矢量...等等组成的集合。其中，矢量<A,B)表示由"顶点A"指向"顶点B"的有向边。

#### 3. 邻接点和度

##### **3.1 邻接点**

一条边上的两个顶点叫做邻接点。

*例如，上面无向图G0中的顶点A和顶点C就是邻接点。*

在有向图中，除了邻接点之外；还有"入边"和"出边"的概念。

顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。

*例如，上面有向图G2中的B和E是邻接点；是B的出边，还是E的入边。*

##### **3.2 度**

在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。

*例如，上面无向图G0中顶点A的度是2。*

在有向图中，度还有"入度"和"出度"之分。

某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。 顶点的度=入度+出度。

*例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。*

#### 4. 路径和回路

**路径**：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。

**路径长度**：路径中"边的数量"。

**简单路径**：若一条路径上顶点不重复出现，则是简单路径。

**回路**：若路径的第一个顶点和最后一个顶点相同，则是回路。

**简单回路**：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。

#### 5. 连通图和连通分量

**连通图**：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。

**连通分量**：非连通图中的各个连通子图称为该图的连通分量。

#### 6. 权

在学习"哈夫曼树"的时候，了解过"权"的概念。图中权的概念与此类似。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/03.jpg?raw=true&_=3691463)

上面就是一个带权的图。

### 二、图的存储结构

上面了解了"图的基本概念"，下面开始介绍图的存储结构。图的存储结构，常用的是"**邻接矩阵**"和"**邻接表**"。

#### 1. 邻接矩阵

邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。 假设图中顶点数为n，则邻接矩阵定义为：

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/04.jpg?raw=true&_=3691463)

下面通过示意图来进行解释。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/05.jpg?raw=true&_=3691463)

图中的G1是无向图和它对应的邻接矩阵。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/06.jpg?raw=true&_=3691463)

图中的G2是无向图和它对应的邻接矩阵。

通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。 邻接矩阵的缺点就是比较耗费空间。



##### 优点

容易判断两个顶点间是否有边

容易计算顶点的度（出/入）



##### 缺点

统计边的数量效率较低（时间复杂度O(n²)）

空间复杂度高（空间复杂度O(n²)）



#### 2. 邻接表

邻接表是图的一种链式存储表示方法。它是改进后的"邻接矩阵"，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/07.jpg?raw=true&_=3691463)

图中的G1是无向图和它对应的邻接矩阵。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/basic/08.jpg?raw=true&_=3691463)

图中的G2是有向图和它对应的邻接矩阵。

优缺点和上面相反。





### 三、图的深度/广度优先遍历

#### 1. 深度优先搜索介绍

图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。

它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

显然，深度优先搜索是一个递归的过程。

#### 2. 深度优先搜索图解

##### **2.1 无向图的深度优先搜索**

下面以"无向图"为例，来对深度优先搜索进行演示。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/01.jpg?raw=true&_=3711483)

对上面的图G1进行深度优先遍历，从顶点A开始。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/02.jpg?raw=true&_=3711483)

**第1步**：访问A。

**第2步**：访问(A的邻接点)C。

 在第1步访问A之后，接下来应该访问的是A的邻接点，即"C,D,F"中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在"D和F"的前面，因此，先访问C。

**第3步**：访问(C的邻接点)B。

 在第2步访问C之后，接下来应该访问C的邻接点，即"B和D"中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。

**第4步**：访问(C的邻接点)D。

 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。

**第5步**：访问(A的邻接点)F。

 前面已经访问了A，并且访问完了"A的邻接点B的所有邻接点(包括递归的邻接点在内)"；因此，此时返回到访问A的另一个邻接点F。

**第6步**：访问(F的邻接点)G。

**第7步**：访问(G的邻接点)E。

因此访问顺序是：**A -> C -> B -> D -> F -> G -> E**

##### **2.2 有向图的深度优先搜索**

下面以"有向图"为例，来对深度优先搜索进行演示。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/03.jpg?raw=true&_=3711483)

对上面的图G2进行深度优先遍历，从顶点A开始。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/04.jpg?raw=true&_=3711483)

**第1步**：访问A。

**第2步**：访问B。

 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。

**第3步**：访问C。

 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。

**第4步**：访问E。

 接下来访问C的出边的另一个顶点，即顶点E。

**第5步**：访问D。

 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。

**第6步**：访问F。

 接下应该回溯"访问A的出边的另一个顶点F"。

**第7步**：访问G。

因此访问顺序是：**A -> B -> C -> E -> D -> F -> G**



![无向图非连通](.\res\无向图非连通.png)

非连通无向图，执行几次深度优先搜索，就有几个连通分量





#### 3. 广度优先搜索介绍

广度优先搜索算法(Breadth First Search)，又称为"宽度优先搜索"或"横向优先搜索"，简称BFS。

它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。

#### 4. 广度优先搜索图解

##### **4.1 无向图的广度优先搜索**

下面以"无向图"为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/05.jpg?raw=true&_=3711483)

**第1步**：访问A。

**第2步**：依次访问C,D,F。

 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在"D和F"的前面，因此，先访问C。再访问完C之后，再依次访问D,F。

**第3步**：依次访问B,G。

 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。

**第4步**：访问E。 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。

因此访问顺序是：**A -> C -> D -> F -> B -> G -> E**

##### **4.2 有向图的广度优先搜索**

下面以"有向图"为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。

![img](https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/iterator/06.jpg?raw=true&_=3711483)

**第1步**：访问A。

**第2步**：访问B。

**第3步**：依次访问C,E,F。

 在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。

**第4步**：依次访问D,G。 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。

因此访问顺序是：**A -> B -> C -> E -> F -> D -> G**





非连通无向图，执行几次广度优先搜索，就有几个连通分量，同上面深度优先



### 四、最小生成树-Prime(普里姆)算法 和 Kruskal(克鲁斯卡尔)算法

最小生成树-边权和最小。



#### 普里姆算法

![最小生成树-普里姆算法](D:\系统文件\Document\学习\Learning-Documents\算法与数据结构\res\最小生成树-普里姆算法.png)

随机一个点开始，按照最小路径来依次添加点，生成结果不唯一。

特性：以点为核心来推进的算法，更适合稠密图，与边的数量无关。





#### 克鲁斯卡尔算法（加边法）

![最小生成树-克鲁斯卡尔算法](.\res\最小生成树-克鲁斯卡尔算法.png)

从最小边开始加，如果两个点未连通，且不是一个连通分量，就添加上边，挨个添加知道所有的点都可及。

特性：以边为核心来推荐算法，更适合稀疏图。



### 五、最短路径

#### Dijkstra(迪杰斯特拉)算法

用来求**单元最短路径**，某一个点到其他点的最短路径。

![单元最短路径-迪杰斯特拉算法](.\res\单元最短路径-迪杰斯特拉算法.png)

每次确定一个最短的路径，进行下一轮最短路径确定，无法连通的标为无穷大，后续发现更短路径更新。



#### Floyd(弗洛伊德)算法

用来求任意两个点的最短路径

 ![最短路径-弗洛伊德算法示例](.\res\最短路径-弗洛伊德算法示例.png)

示例为图，及其对应的邻接矩阵。自身标0，没有边标无穷。

根据原始数据，生成Distance表和Path表，D表表示最短距离，P表到达路径，如第一列第二行表示，1到0的路径，这个路径上0上一个点位1。

 ![弗洛伊德算法-步骤1](.\res\弗洛伊德算法-步骤1.png)



然后将点依次作为中间点来确认路径，如果更短就更新，同时更新D表和P表

 ![弗洛伊德算法-步骤2](.\res\弗洛伊德算法-步骤2.png)

其中，自身到自身，已经自身到其他点不用更新。如上图为0作为中间点时，对角线，以及第一行第一列不用更新，需要更新的为1到2,0作为中间点，即1->0->2，2->0->1，两个。如果计算出来比当前记录短就更新，且此时同步更新P表，查询P表中，此路径上到这个点的上一个点。

依次将1,2作为中间点更新表

 ![弗洛伊德算法-步骤3](.\res\弗洛伊德算法-步骤3.png)



 ![弗洛伊德算法-步骤4](.\res\弗洛伊德算法-步骤4.png)

更新完成，此时这两个表就为结果，通过两个表可以查询到任意两个点的最短距离。

例如求1->2的最短距离及路径，通过D表第二行第三列得知，最短距离为4，通过P表第二行第三列地址此路径上2的上一个点为1，所以路径就是1->2。

再例如求1->0，通过D表第二行第一列得知最短距离是9，通过P表第二行第二列得知此路径上0的上一个点为2，那就在看1->2的最短路径，即第二行第三列1->2的最短路径上2的上一个点是1，即为自己，所以综上路径为1->2->0





### 六、拓扑排序

将图上所有点按照先后顺序排成序列。PS：前提需要图为**有向无环图**。

 ![拓扑排序](.\res\拓扑排序.png)

如果有环的话，会出现没有入度为0的点，进行不下去，反之拓扑排序可以判断图里是否有环。



##### AOE网

边活动网 Activity on Edge Network

描述工程

![AOE网](.\res\AOE网.png)

完成整个工程至少需要花多长时间  ->  哪条路径最耗时？ 即为**关键路径**



###### 关键路径

![关键路径](.\res\关键路径.png)

求ve：按照拓扑排序的方式，挨个访问没有入度的点检查活动，ve更新最大权值。例如：V3的ve应该是5，V2的时候，发现v3有3 较小的值，没有之前记录的5大，就不更新，仍然是5。



![关键路径-ve.png](.\res\关键路径-ve.png)

逆拓扑排序：每次选出出度为0的点，然后删除这个点和它的入边。

求vl：最后一个点的ve和vl是相同的，然后把所有的vl先赋值最后一个点的vl即最后一个点的ve。使用逆拓扑排序，判断点和它的入边，最后的vl减去权，更新vl，vl每次都记录最小的值。

![关键路径-vl](.\res\关键路径-vl.png)



然后根据求好的点的最早最晚开始时间，来算出边的最早最晚开始时间，边的最早开始时间就是发出点的最早开始时间、最晚开始时间是边入度的点的最晚开始时间减去边的权。
![关键路径-边的e、l](.\res\关键路径-边的e、l.png)

e、l相同的边（相同意味着没有时间余量），就是关键边，由关键边构成的路径就是关键路径。



## 散列查找

### 一、什么是哈希表

哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。

哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

使用哈希查找有两个步骤:

1. 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突
2. 处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。

哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。

### 二、哈希函数

哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。比如举个简单的例子，使用手机号码后三位就比前三位作为key更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。

在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。

#### 1. 正整数

获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。

#### 2. 字符串

将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如

```java
public int GetHashCode(string str)
{
    char[] s = str.ToCharArray();
    int hash = 0;
    for (int i = 0; i < s.Length; i++)
    {
        hash = s[i] + (31 * hash); 
    }
    return hash;
}
```

上面的哈希值是Horner计算字符串哈希值的方法，公式为:

![img](https://lrh1993.gitbooks.io/android_interview_guide/content/assets/hash.png)

举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为

![img](https://lrh1993.gitbooks.io/android_interview_guide/content/assets/hash-result.png)

如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈希值来节省时间，比如，可以 获取每8-9个字符来获取哈希值：

```Java
public int GetHashCode(string str)
{
    char[] s = str.ToCharArray();
    int hash = 0;
    int skip = Math.Max(1, s.Length / 8);
    for (int i = 0; i < s.Length; i+=skip)
    {
        hash = s[i] + (31 * hash);
    }
    return hash;
}
```

但是，对于某些情况，不同的字符串会产生相同的哈希值，这就是前面说到的哈希冲突（Hash Collisions），比如下面的四个字符串：

[![hash code collision](http://images.cnitblog.com/blog/94031/201410/312300343319616.jpg)](http://images.cnitblog.com/blog/94031/201410/312300323153434.jpg)

如果我们按照每8个字符取哈希的话，就会得到一样的哈希值。所以下面来讲解如何解决哈希碰撞：

### 三、避免哈希冲突

#### 拉链法

通过哈希函数，我们可以将键转换为数组的索引(0-M-1)，但是对于两个或者多个键具有相同索引值的情况，我们需要有一种方法来处理这种冲突。

一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法。下图很清楚的描述了什么是拉链法。

[![seperate chaining with link list ](http://images.cnitblog.com/blog/94031/201410/312300382371659.png)](http://images.cnitblog.com/blog/94031/201410/312300363318272.png)

图中，”John Smith”和”Sandra Dee” 通过哈希函数都指向了152 这个索引，该索引又指向了一个链表， 在链表中依次存储了这两个字符串。

该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到对应的链表，然后沿着链表顺序找到相应的键。

实现基于拉链表的散列表，目标是选择适当的数组大小M，使得既不会因为空链表而浪费内存空间，也不会因为链表太而在查找上浪费太多时间。拉链表的优点在于，这种数组大小M的选择不是关键性的，如果存入的键多于预期，那么查找的时间只会比选择更大的数组稍长，另外，我们也可以使用更高效的结构来代替链表存储。如果存入的键少于预期，索然有些浪费空间，但是查找速度就会很快。所以当内存不紧张时，我们可以选择足够大的M，可以使得查找时间变为常数，如果内存紧张时，选择尽量大的M仍能够将性能提高M倍。

#### 线性探测法

线性探测法是[开放寻址法](http://en.wikipedia.org/wiki/Hash_table)解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M>N，我们需要使用数组中的空位解决碰撞冲突。如下图所示：

[![open address  ](http://images.cnitblog.com/blog/94031/201410/312300528784418.png)](http://images.cnitblog.com/blog/94031/201410/312300395342227.png)

对照前面的拉链法，在该图中，”Ted Baker” 是有唯一的哈希值153的，但是由于153被”Sandra Dee”占用了。而原先”Snadra Dee”和”John Smith”的哈希值都是152的，但是在对”Sandra Dee”进行哈希的时候发现152已经被占用了，所以往下找发现153没有被占用，所以存放在153上，然后”Ted Baker”哈希到153上，发现已经被占用了，所以往下找，发现154没有被占用，所以值存到了154上。

开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：

1. 命中，该位置的键和被查找的键相同
2. 未命中，键为空
3. 继续查找，该位置的键和被查找的键不同。

线性探查（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。