# 数据结构与算法分析学习



## 第一章：基础回顾

### 数学公式学习回顾：

略





### 递归简论

递归需要两个条件才能够正常运作：

#### 1.基准情形：基准情形作为程序的出口，保证它们不用递归就能够求解。

#### 2.不断推进：对于递归运作中，必须总能够朝着产生基准情形的方向推进。

满足这两个条件， 递归才能够正常运作。



此外：

#### 3.设计法则：假设所有的递归的调用都能够运行。

#### 4.合成效益法则：在求解一个问题的同一实例时，切勿在不用的递归调用中做任何重复性的工作。 



## 第二章：算法分析

### 数学基础：

以增长率对大部分常见函数分类：

 ![fx_2_1](.\res\fx_2_1.png)

越往下增长速度越快。 其中 log²N = (logN)²

 

### 算法要分析问题：

首先，为了便于分析问题的情况，我们需要一个**计算模型**，即一台虚拟假定的计算机，指令能在计算机中按顺序执行，此计算机做一个“简单”的工作都只需要花费**一个时间单元**，哪怕是IO操作，和二位数加减法操作，两者都需要相同的一个时间单元，且此计算机拥有**无限的内存**。

这个模型现实中无法存在，且有很多问题，但是能极大纯度简化问题，且有一个标准来帮忙分析算法问题。

通常而言，要分析的最重要的资源一般来说就是**运行时间**，且此运行时间不是程序的平均运行时间，在没有特殊指定的情况下，一般表示最大的运行时间，即**最坏情况下的运行时间**。



#### 分析方法：

按顺序累加执行代码的时间单元，归纳成为O(N)，其实本质上就是统计时间复杂度。

方法：循环或者递归计算按最多次数计算，嵌套循环累乘，if else等判断取较长的一边。



### 对分查找：

​	效率非常高，时间复杂度为**O(logN)**，前提是在排序完成且已经读入好的数据进行查找。



### 欧几里得算法：

​	求两个数之间的最大公约数，时间复杂度也是**O(logN)**，算法本质为**辗转相除法**，即用大的数除以小的数字，取余数代替大的数字继续，大除以小，直到整除，整除时的除数就是最大公约数。



### 高效幂运算算法：

​	通常幂运算的次数，就是乘法的次数，即X^5 = X * X * X * X * X，即4次，时间复杂度为O(N)，但是可以用递归实现一个高效的算法其时间复杂度为O(logN):

```c
long int pow(long int x,unsigned int N){
	if(N == 0){
		return 1;
	}else if(N == 1){
		return x;
	}else if(N & 1){
		//位运算判断奇偶，二进制下第一位1就是奇数
		return pow(x * x, N / 2) * x;
	}else{
		return pow(x * x, N / 2);
	}
}
```

##### 运行示例：

假设我们调用 `pow(2, 10)`，计算过程如下：

1. `pow(2, 10)` 调用 `pow(4, 5)`，因为 10 是偶数。
2. `pow(4, 5)` 调用 `pow(16, 2)`，并将结果乘以 4，因为 5 是奇数。
3. `pow(16, 2)` 调用 `pow(256, 1)`，因为 2 是偶数。
4. `pow(256, 1)` 返回 256，因为 N=1N = 1N=1。
5. 结果：4×256=10244 \times 256 = 10244×256=1024。

因此，`pow(2, 10)` 的结果为 1024。

​	这个递归算法通过减少计算次数，使用了**快速幂**的思想，并使用了位运算来判断奇偶性，显著提高了计算效率。

##### 分析结果的检验：

​	通常可以将N扩大一倍，或者多倍来匹配对应的运行时间增长情况。

​	![fx_2_4_5](.\res\fx_2_4_5.png)



